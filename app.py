import streamlit as st  
import pandas as pd  
import numpy as np  
import matplotlib.pyplot as plt  
from io import BytesIO  
from scipy.special import factorial  
from sklearn.linear_model import LogisticRegression  
from sklearn.ensemble import RandomForestClassifier  
from xgboost import XGBClassifier  
from docx import Document  

# Fonction pour pr√©dire avec le mod√®le Poisson  
def poisson_prediction(home_goals, away_goals):  
    home_prob = np.exp(-home_goals) * (home_goals ** home_goals) / factorial(home_goals)  
    away_prob = np.exp(-away_goals) * (away_goals ** away_goals) / factorial(away_goals)  
    return home_prob, away_prob  

# Fonction pour calculer les paris double chance  
def double_chance_probabilities(home_prob, away_prob):  
    return {  
        "1X": home_prob + (1 - away_prob),  
        "X2": away_prob + (1 - home_prob),  
        "12": home_prob + away_prob  
    }  

# Fonction pour cr√©er un document Word avec les r√©sultats  
def create_doc(results):  
    doc = Document()  
    doc.add_heading('Analyse de Matchs de Football et Pr√©dictions de Paris Sportifs', level=1)  

    # Ajout des donn√©es des √©quipes  
    doc.add_heading('Donn√©es des √âquipes', level=2)  
    doc.add_paragraph(f"√âquipe Domicile: {results['√âquipe Domicile']}")  
    doc.add_paragraph(f"√âquipe Ext√©rieure: {results['√âquipe Ext√©rieure']}")  
    doc.add_paragraph(f"Buts Pr√©dit Domicile: {results['Buts Pr√©dit Domicile']:.2f}")  
    doc.add_paragraph(f"Buts Pr√©dit Ext√©rieur: {results['Buts Pr√©dit Ext√©rieur']:.2f}")  

    # Ajout des probabilit√©s des mod√®les  
    doc.add_heading('Probabilit√©s des Mod√®les', level=2)  
    doc.add_paragraph(f"Probabilit√© Domicile: {results['Probabilit√© Domicile']:.2f}")  
    doc.add_paragraph(f"Probabilit√© Nul: {results['Probabilit√© Nul']:.2f}")  
    doc.add_paragraph(f"Probabilit√© Ext√©rieure: {results['Probabilit√© Ext√©rieure']:.2f}")  

    # Ajout des probabilit√©s des paris double chance  
    doc.add_heading('Probabilit√©s des Paris Double Chance', level=2)  
    for bet, prob in results.items():  
        if "Paris Double Chance" in bet:  
            doc.add_paragraph(f"{bet}: {prob:.2f}")  

    # Enregistrement du document  
    buffer = BytesIO()  
    doc.save(buffer)  
    buffer.seek(0)  
    return buffer  

# Fonction pour entra√Æner et pr√©dire avec les mod√®les  
@st.cache_resource  
def train_models():  
    # Cr√©er un ensemble de donn√©es d'entra√Ænement fictif plus petit  
    data = pd.DataFrame({  
        'home_goals': np.random.randint(0, 3, size=50),  # R√©duire la taille √† 50  
        'away_goals': np.random.randint(0, 3, size=50),  
        'home_xG': np.random.uniform(0, 2, size=50),  
        'away_xG': np.random.uniform(0, 2, size=50),  
        'home_defense': np.random.randint(0, 3, size=50),  
        'away_defense': np.random.randint(0, 3, size=50),  
        'result': np.random.choice([0, 1, 2], size=50)  # 0 pour victoire ext√©rieure, 1 pour match nul, 2 pour victoire domicile  
    })  

    # S√©parer les caract√©ristiques et la cible  
    X = data[['home_goals', 'away_goals', 'home_xG', 'away_xG', 'home_defense', 'away_defense']]  
    y = data['result']  

    # Mod√®le de r√©gression logistique  
    log_reg = LogisticRegression(max_iter=100)  # Limiter le nombre d'it√©rations  
    log_reg.fit(X, y)  

    # Mod√®le Random Forest  
    rf = RandomForestClassifier(n_estimators=10)  # R√©duire le nombre d'estimateurs  
    rf.fit(X, y)  

    # Mod√®le XGBoost  
    xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', n_estimators=10)  # R√©duire le nombre d'estimateurs  
    xgb.fit(X, y)  

    return log_reg, rf, xgb  

# V√©rifier si les mod√®les sont d√©j√† charg√©s dans l'√©tat de session  
if 'models' not in st.session_state:  
    st.session_state.models = train_models()  

log_reg_model, rf_model, xgb_model = st.session_state.models  

# Interface utilisateur  
st.title("üèÜ Analyse de Matchs de Football et Pr√©dictions de Paris Sportifs")  

# Saisie des donn√©es des √©quipes  
st.header("Saisie des donn√©es des √©quipes")  
col1, col2 = st.columns(2)  

with col1:  
    home_team = st.text_input("Nom de l'√©quipe √† domicile", value="√âquipe A")  
    st.subheader("Statistiques de l'√©quipe √† domicile")  
    home_stats = {  
        "moyenne_buts_marques": st.number_input("Moyenne de buts marqu√©s par match (domicile)", min_value=0.0, value=2.5),  
        "xG": st.number_input("xG (Expected Goals) (domicile)", min_value=0.0, value=2.0),  
        "moyenne_buts_encais": st.number_input("Moyenne de buts encaiss√©s par match (domicile)", min_value=0.0, value=1.0),  
        "XGA": st.number_input("xGA (Expected Goals Against) (domicile)", min_value=0.0, value=1.5),  
        "tires_par_match": st.number_input("Nombres de tirs par match (domicile)", min_value=0, value=15),  
        "passes_menant_a_tir": st.number_input("Nombres de passes menant √† un tir (domicile)", min_value=0, value=10),  
        "tirs_cadres": st.number_input("Tirs cadr√©s par match (domicile)", min_value=0, value=5),  
        "tires_concedes": st.number_input("Nombres de tirs conc√©d√©s par match (domicile)", min_value=0, value=8),  
        "duels_defensifs": st.number_input("Duels d√©fensifs gagn√©s (%) (domicile)", min_value=0.0, max_value=100.0, value=60.0),  
        "possession": st.number_input("Possession moyenne (%) (domicile)", min_value=0.0, max_value=100.0, value=55.0),  
        "passes_reussies": st.number_input("Passes r√©ussies (%) (domicile)", min_value=0.0, max_value=100.0, value=80.0),  
        "touches_surface": st.number_input("Balles touch√©es dans la surface adverse (domicile)", min_value=0, value=20),  
        "forme_recente": st.number_input("Forme r√©cente (points sur les 5 derniers matchs) (domicile)", min_value=0, value=10),  
    }  

with col2:  
    away_team = st.text_input("Nom de l'√©quipe √† l'ext√©rieur", value="√âquipe B")  
    st.subheader("Statistiques de l'√©quipe √† l'ext√©rieur")  
    away_stats = {  
        "moyenne_buts_marques": st.number_input("Moyenne de buts marqu√©s par match (ext√©rieur)", min_value=0.0, value=1.5),  
        "xG": st.number_input("xG (Expected Goals) (ext√©rieur)", min_value=0.0, value=1.8),  
        "moyenne_buts_encais": st.number_input("Moyenne de buts encaiss√©s par match (ext√©rieur)", min_value=0.0, value=2.0),  
        "XGA": st.number_input("xGA (Expected Goals Against) (ext√©rieur)", min_value=0.0, value=2.5),  
        "tires_par_match": st.number_input("Nombres de tirs par match (ext√©rieur)", min_value=0, value=12),  
        "passes_menant_a_tir": st.number_input("Nombres de passes menant √† un tir (ext√©rieur)", min_value=0, value=8),  
        "tirs_cadres": st.number_input("Tirs cadr√©s par match (ext√©rieur)", min_value=0, value=4),  
        "tires_concedes": st.number_input("Nombres de tirs conc√©d√©s par match (ext√©rieur)", min_value=0, value=10),  
        "duels_defensifs": st.number_input("Duels d√©fensifs gagn√©s (%) (ext√©rieur)", min_value=0.0, max_value=100.0, value=50.0),  
        "possession": st.number_input("Possession moyenne (%) (ext√©rieur)", min_value=0.0, max_value=100.0, value=45.0),  
        "passes_reussies": st.number_input("Passes r√©ussies (%) (ext√©rieur)", min_value=0.0, max_value=100.0, value=75.0),  
        "touches_surface": st.number_input("Balles touch√©es dans la surface adverse (ext√©rieur)", min_value=0, value=15),  
        "forme_recente": st.number_input("Forme r√©cente (points sur les 5 derniers matchs) (ext√©rieur)", min_value=0, value=8),  
    }  

# Saisie des cotes des bookmakers  
st.header("Saisie des cotes des bookmakers")  
odds_home = st.number_input("Cote pour l'√©quipe √† domicile", min_value=1.0, value=1.8)  
odds_away = st.number_input("Cote pour l'√©quipe √† l'ext√©rieur", min_value=1.0, value=2.2)  

# Pr√©dictions  
if st.button("üîç Pr√©dire les r√©sultats"):  
    home_goals = home_stats["moyenne_buts_marques"] + home_stats["xG"] - away_stats["moyenne_buts_encais"]  
    away_goals = away_stats["moyenne_buts_marques"] + away_stats["xG"] - home_stats["moyenne_buts_encais"]  
    
    home_prob, away_prob = poisson_prediction(home_goals, away_goals)  

    # Pr√©dictions avec les mod√®les  
    input_data = [[home_stats['moyenne_buts_marques'], away_stats['moyenne_buts_marques'], home_stats['xG'], away_stats['xG'], home_stats['moyenne_buts_encais'], away_stats['moyenne_buts_encais']]]  
    st.write("Donn√©es d'entr√©e pour les pr√©dictions :", input_data)  

    try:  
        log_reg_prob = log_reg_model.predict_proba(input_data)[0]  
        rf_prob = rf_model.predict_proba(input_data)[0]  
        xgb_prob = xgb_model.predict_proba(input_data)[0]  
    except Exception as e:  
        st.error(f"Erreur lors de la pr√©diction : {e}")  
        log_reg_prob, rf_prob, xgb_prob = None, None, None  

    # Affichage des r√©sultats  
    st.subheader("üìä R√©sultats des Pr√©dictions")  

    # Section pour les buts pr√©dit  
    st.markdown("### Nombre de buts pr√©dit")  
    st.write(f"**Nombre de buts pr√©dit pour {home_team} :** {home_goals:.2f} ({home_prob * 100:.2f}%)")  
    st.write(f"**Nombre de buts pr√©dit pour {away_team} :** {away_goals:.2f} ({away_prob * 100:.2f}%)")  

    # Section pour les probabilit√©s des mod√®les  
    st.markdown("### Probabilit√©s des Mod√®les")  
    model_results = {  
        "Mod√®le": ["R√©gression Logistique", "Random Forest", "XGBoost"],  
        "Victoire Domicile (%)": [log_reg_prob[2] * 100 if log_reg_prob is not None else None,  
                                  rf_prob[2] * 100 if rf_prob is not None else None,  
                                  xgb_prob[2] * 100 if xgb_prob is not None else None],  
        "Match Nul (%)": [log_reg_prob[1] * 100 if log_reg_prob is not None else None,  
                          rf_prob[1] * 100 if rf_prob is not None else None,  
                          xgb_prob[1] * 100 if xgb_prob is not None else None],  
        "Victoire Ext√©rieure (%)": [log_reg_prob[0] * 100 if log_reg_prob is not None else None,  
                                    rf_prob[0] * 100 if rf_prob is not None else None,  
                                    xgb_prob[0] * 100 if xgb_prob is not None else None],  
    }  
    model_results_df = pd.DataFrame(model_results)  
    st.dataframe(model_results_df)  

    # Calcul des paris double chance  
    if home_prob is not None and away_prob is not None:  
        double_chance = double_chance_probabilities(home_prob, away_prob)  
        st.markdown("### Probabilit√©s des Paris Double Chance")  
        double_chance_df = pd.DataFrame(double_chance.items(), columns=["Paris", "Probabilit√© (%)"])  
        st.dataframe(double_chance_df)  

    # Visualisation des r√©sultats  
    if log_reg_prob is not None and len(log_reg_prob) == 3:  
        fig, ax = plt.subplots()  
        ax.bar(["Domicile", "Nul", "Ext√©rieur"], [log_reg_prob[2], log_reg_prob[1], log_reg_prob[0]], color=['blue', 'orange', 'green'])  
        ax.set_ylabel("Probabilit√©s")  
        ax.set_title("Probabilit√©s des r√©sultats")  
        st.pyplot(fig)  
    else:  
        st.error("Impossible de visualiser les r√©sultats en raison d'une erreur dans les probabilit√©s pr√©dites.")  

    # Gestion de la bankroll  
    st.subheader("üí∞ Gestion de la bankroll")  

    # Conversion des cotes en probabilit√©s implicites  
    implied_prob_home = 1 / odds_home  
    implied_prob_away = 1 / odds_away  
    st.write(f"**Probabilit√© implicite pour {home_team} :** {implied_prob_home * 100:.2f}%")  
    st.write(f"**Probabilit√© implicite pour {away_team} :** {implied_prob_away * 100:.2f}%")  

    # Comparaison avec les probabilit√©s des mod√®les  
    st.subheader("üîç Comparaison des Probabilit√©s")  
    if log_reg_prob is not None and len(log_reg_prob) == 3:  
        st.write(f"**Probabilit√© de victoire selon la r√©gression logistique pour {home_team} :** {log_reg_prob[2] * 100:.2f}%")  
        st.write(f"**Probabilit√© de victoire selon la r√©gression logistique pour {away_team} :** {log_reg_prob[0] * 100:.2f}%")  

        # D√©tection de valeur de pari  
        if log_reg_prob[2] > implied_prob_home:  
            st.success(f"Opportunit√© de pari sur {home_team} !")  
        if log_reg_prob[0] > implied_prob_away:  
            st.success(f"Opportunit√© de pari sur {away_team} !")  

    # Option de t√©l√©chargement des r√©sultats  
    results = {  
        "√âquipe Domicile": home_team,  
        "√âquipe Ext√©rieure": away_team,  
        "Buts Pr√©dit Domicile": home_goals,  
        "Buts Pr√©dit Ext√©rieur": away_goals,  
        "Probabilit√© Domicile": log_reg_prob[2] if log_reg_prob is not None else None,  
        "Probabilit√© Nul": log_reg_prob[1] if log_reg_prob is not None else None,  
        "Probabilit√© Ext√©rieure": log_reg_prob[0] if log_reg_prob is not None else None,  
        "Probabilit√© R√©gression Logistique": log_reg_prob,  
        "Probabilit√© Random Forest": rf_prob,  
        "Probabilit√© XGBoost": xgb_prob,  
        "Paris Double Chance 1X": double_chance["1X"] if 'double_chance' in locals() else None,  
        "Paris Double Chance X2": double_chance["X2"] if 'double_chance' in locals() else None,  
        "Paris Double Chance 12": double_chance["12"] if 'double_chance' in locals() else None,  
    }  

    if st.button("üì• T√©l√©charger les r√©sultats en DOC"):  
        buffer = create_doc(results)  
        st.download_button(  
            label="T√©l√©charger les r√©sultats",  
            data=buffer,  
            file_name="predictions.docx",  
            mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"  
        )
